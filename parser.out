Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BOOLEAN
    BOOLEANCAST
    CATCH
    DEF
    DOUBLECAST
    EMPTY
    EQUALITY
    FINALLY
    FOREACH
    GREATER
    GREATEREQUAL
    HEAD
    IMPLIES
    INTEGERCAST
    LBRACK
    LEN
    LESS
    LESSEQUAL
    NAMESPACE_OP
    NOT
    NULL
    OR
    RBRACK
    STRINGCAST
    TAIL
    TRY

Grammar

Rule 0     S' -> program
Rule 1     program -> definitions imports expression
Rule 2     program -> imports expression
Rule 3     program -> definitions expression
Rule 4     program -> imports
Rule 5     program -> definitions
Rule 6     program -> expression
Rule 7     expression -> LET IDENTIFIER EQUALS expression IN expression
Rule 8     expression -> expression PLUS expression
Rule 9     expression -> expression MINUS expression
Rule 10    expression -> expression TIMES expression
Rule 11    expression -> expression DIVIDE expression
Rule 12    namespace -> IDENTIFIER
Rule 13    namespace -> namespace DOT IDENTIFIER
Rule 14    import -> IMPORT IDENTIFIER AS IDENTIFIER
Rule 15    imports -> import
Rule 16    imports -> imports import
Rule 17    expression -> MINUS expression
Rule 18    expression -> LPAREN expression RPAREN
Rule 19    term -> factor
Rule 20    factor -> STRING
Rule 21    factor -> NUMBER
Rule 22    factor -> TRUE
Rule 23    factor -> FALSE
Rule 24    expression -> WHILE expression DO expression
Rule 25    expression -> IF expression THEN expression ELSE expression
Rule 26    expression -> IF expression THEN expression
Rule 27    expression -> LAZY expression
Rule 28    expression -> LCBRACE expression RCBRACE
Rule 29    expression -> LAMBDA LPAREN args RPAREN expression
Rule 30    expression -> expression PIPE expression
Rule 31    expression -> function_call
Rule 32    expression -> term
Rule 33    function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE
Rule 34    definitions -> function_definition
Rule 35    definitions -> definitions function_definition
Rule 36    function_call -> function_call LPAREN args RPAREN
Rule 37    function_call -> IDENTIFIER LPAREN args RPAREN
Rule 38    function_call -> IDENTIFIER
Rule 39    args -> args COMMA arg
Rule 40    args -> arg
Rule 41    args -> <empty>
Rule 42    arg -> expression

Terminals, with rules where they appear

AND                  : 
AS                   : 14
BOOLEAN              : 
BOOLEANCAST          : 
CATCH                : 
COMMA                : 39
DEF                  : 
DIVIDE               : 11
DO                   : 24
DOT                  : 13
DOUBLECAST           : 
ELSE                 : 25
EMPTY                : 
EQUALITY             : 
EQUALS               : 7
FALSE                : 23
FINALLY              : 
FOREACH              : 
FUNC                 : 33
GREATER              : 
GREATEREQUAL         : 
HEAD                 : 
IDENTIFIER           : 7 12 13 14 14 33 37 38
IF                   : 25 26
IMPLIES              : 
IMPORT               : 14
IN                   : 7
INTEGERCAST          : 
LAMBDA               : 29
LAZY                 : 27
LBRACK               : 
LCBRACE              : 28 33
LEN                  : 
LESS                 : 
LESSEQUAL            : 
LET                  : 7
LPAREN               : 18 29 33 36 37
MINUS                : 9 17
NAMESPACE_OP         : 
NOT                  : 
NULL                 : 
NUMBER               : 21
OR                   : 
PIPE                 : 30
PLUS                 : 8
RBRACK               : 
RCBRACE              : 28 33
RPAREN               : 18 29 33 36 37
STRING               : 20
STRINGCAST           : 
TAIL                 : 
THEN                 : 25 26
TIMES                : 10
TRUE                 : 22
TRY                  : 
WHILE                : 24
error                : 

Nonterminals, with rules where they appear

arg                  : 39 40
args                 : 29 33 36 37 39
definitions          : 1 3 5 35
expression           : 1 2 3 6 7 7 8 8 9 9 10 10 11 11 17 18 24 24 25 25 25 26 26 27 28 29 30 30 33 42
factor               : 19
function_call        : 31 36
function_definition  : 34 35
import               : 15 16
imports              : 1 2 4 16
namespace            : 13
program              : 0
term                 : 32

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . definitions imports expression
    (2) program -> . imports expression
    (3) program -> . definitions expression
    (4) program -> . imports
    (5) program -> . definitions
    (6) program -> . expression
    (34) definitions -> . function_definition
    (35) definitions -> . definitions function_definition
    (15) imports -> . import
    (16) imports -> . imports import
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (33) function_definition -> . FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE
    (14) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    FUNC            shift and go to state 18
    IMPORT          shift and go to state 19
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    program                        shift and go to state 1
    definitions                    shift and go to state 2
    imports                        shift and go to state 3
    expression                     shift and go to state 4
    function_definition            shift and go to state 5
    import                         shift and go to state 6
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 1

    (0) S' -> program .



state 2

    (1) program -> definitions . imports expression
    (3) program -> definitions . expression
    (5) program -> definitions .
    (35) definitions -> definitions . function_definition
    (15) imports -> . import
    (16) imports -> . imports import
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (33) function_definition -> . FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE
    (14) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    $end            reduce using rule 5 (program -> definitions .)
    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    FUNC            shift and go to state 18
    IMPORT          shift and go to state 19
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    imports                        shift and go to state 25
    expression                     shift and go to state 26
    function_definition            shift and go to state 27
    import                         shift and go to state 6
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 3

    (2) program -> imports . expression
    (4) program -> imports .
    (16) imports -> imports . import
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (14) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    $end            reduce using rule 4 (program -> imports .)
    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IMPORT          shift and go to state 19
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 28
    import                         shift and go to state 29
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 4

    (6) program -> expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    $end            reduce using rule 6 (program -> expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 5

    (34) definitions -> function_definition .

    LET             reduce using rule 34 (definitions -> function_definition .)
    MINUS           reduce using rule 34 (definitions -> function_definition .)
    LPAREN          reduce using rule 34 (definitions -> function_definition .)
    WHILE           reduce using rule 34 (definitions -> function_definition .)
    IF              reduce using rule 34 (definitions -> function_definition .)
    LAZY            reduce using rule 34 (definitions -> function_definition .)
    LCBRACE         reduce using rule 34 (definitions -> function_definition .)
    LAMBDA          reduce using rule 34 (definitions -> function_definition .)
    FUNC            reduce using rule 34 (definitions -> function_definition .)
    IMPORT          reduce using rule 34 (definitions -> function_definition .)
    IDENTIFIER      reduce using rule 34 (definitions -> function_definition .)
    STRING          reduce using rule 34 (definitions -> function_definition .)
    NUMBER          reduce using rule 34 (definitions -> function_definition .)
    TRUE            reduce using rule 34 (definitions -> function_definition .)
    FALSE           reduce using rule 34 (definitions -> function_definition .)
    $end            reduce using rule 34 (definitions -> function_definition .)


state 6

    (15) imports -> import .

    LET             reduce using rule 15 (imports -> import .)
    MINUS           reduce using rule 15 (imports -> import .)
    LPAREN          reduce using rule 15 (imports -> import .)
    WHILE           reduce using rule 15 (imports -> import .)
    IF              reduce using rule 15 (imports -> import .)
    LAZY            reduce using rule 15 (imports -> import .)
    LCBRACE         reduce using rule 15 (imports -> import .)
    LAMBDA          reduce using rule 15 (imports -> import .)
    IMPORT          reduce using rule 15 (imports -> import .)
    IDENTIFIER      reduce using rule 15 (imports -> import .)
    STRING          reduce using rule 15 (imports -> import .)
    NUMBER          reduce using rule 15 (imports -> import .)
    TRUE            reduce using rule 15 (imports -> import .)
    FALSE           reduce using rule 15 (imports -> import .)
    $end            reduce using rule 15 (imports -> import .)


state 7

    (7) expression -> LET . IDENTIFIER EQUALS expression IN expression

    IDENTIFIER      shift and go to state 35


state 8

    (37) function_call -> IDENTIFIER . LPAREN args RPAREN
    (38) function_call -> IDENTIFIER .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 36
    PLUS            reduce using rule 38 (function_call -> IDENTIFIER .)
    MINUS           reduce using rule 38 (function_call -> IDENTIFIER .)
    TIMES           reduce using rule 38 (function_call -> IDENTIFIER .)
    DIVIDE          reduce using rule 38 (function_call -> IDENTIFIER .)
    PIPE            reduce using rule 38 (function_call -> IDENTIFIER .)
    $end            reduce using rule 38 (function_call -> IDENTIFIER .)
    RPAREN          reduce using rule 38 (function_call -> IDENTIFIER .)
    DO              reduce using rule 38 (function_call -> IDENTIFIER .)
    THEN            reduce using rule 38 (function_call -> IDENTIFIER .)
    RCBRACE         reduce using rule 38 (function_call -> IDENTIFIER .)
    COMMA           reduce using rule 38 (function_call -> IDENTIFIER .)
    IN              reduce using rule 38 (function_call -> IDENTIFIER .)
    ELSE            reduce using rule 38 (function_call -> IDENTIFIER .)

  ! LPAREN          [ reduce using rule 38 (function_call -> IDENTIFIER .) ]


state 9

    (17) expression -> MINUS . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 37
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 10

    (18) expression -> LPAREN . expression RPAREN
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 38
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 11

    (24) expression -> WHILE . expression DO expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 39
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 12

    (25) expression -> IF . expression THEN expression ELSE expression
    (26) expression -> IF . expression THEN expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 40
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 13

    (27) expression -> LAZY . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 41
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 14

    (28) expression -> LCBRACE . expression RCBRACE
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 42
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 15

    (29) expression -> LAMBDA . LPAREN args RPAREN expression

    LPAREN          shift and go to state 43


state 16

    (31) expression -> function_call .
    (36) function_call -> function_call . LPAREN args RPAREN

    PLUS            reduce using rule 31 (expression -> function_call .)
    MINUS           reduce using rule 31 (expression -> function_call .)
    TIMES           reduce using rule 31 (expression -> function_call .)
    DIVIDE          reduce using rule 31 (expression -> function_call .)
    PIPE            reduce using rule 31 (expression -> function_call .)
    $end            reduce using rule 31 (expression -> function_call .)
    RPAREN          reduce using rule 31 (expression -> function_call .)
    DO              reduce using rule 31 (expression -> function_call .)
    THEN            reduce using rule 31 (expression -> function_call .)
    RCBRACE         reduce using rule 31 (expression -> function_call .)
    COMMA           reduce using rule 31 (expression -> function_call .)
    IN              reduce using rule 31 (expression -> function_call .)
    ELSE            reduce using rule 31 (expression -> function_call .)
    LPAREN          shift and go to state 44


state 17

    (32) expression -> term .

    PLUS            reduce using rule 32 (expression -> term .)
    MINUS           reduce using rule 32 (expression -> term .)
    TIMES           reduce using rule 32 (expression -> term .)
    DIVIDE          reduce using rule 32 (expression -> term .)
    PIPE            reduce using rule 32 (expression -> term .)
    $end            reduce using rule 32 (expression -> term .)
    RPAREN          reduce using rule 32 (expression -> term .)
    DO              reduce using rule 32 (expression -> term .)
    THEN            reduce using rule 32 (expression -> term .)
    RCBRACE         reduce using rule 32 (expression -> term .)
    COMMA           reduce using rule 32 (expression -> term .)
    IN              reduce using rule 32 (expression -> term .)
    ELSE            reduce using rule 32 (expression -> term .)


state 18

    (33) function_definition -> FUNC . IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE

    IDENTIFIER      shift and go to state 45


state 19

    (14) import -> IMPORT . IDENTIFIER AS IDENTIFIER

    IDENTIFIER      shift and go to state 46


state 20

    (19) term -> factor .

    PLUS            reduce using rule 19 (term -> factor .)
    MINUS           reduce using rule 19 (term -> factor .)
    TIMES           reduce using rule 19 (term -> factor .)
    DIVIDE          reduce using rule 19 (term -> factor .)
    PIPE            reduce using rule 19 (term -> factor .)
    $end            reduce using rule 19 (term -> factor .)
    RPAREN          reduce using rule 19 (term -> factor .)
    DO              reduce using rule 19 (term -> factor .)
    THEN            reduce using rule 19 (term -> factor .)
    RCBRACE         reduce using rule 19 (term -> factor .)
    COMMA           reduce using rule 19 (term -> factor .)
    IN              reduce using rule 19 (term -> factor .)
    ELSE            reduce using rule 19 (term -> factor .)


state 21

    (20) factor -> STRING .

    PLUS            reduce using rule 20 (factor -> STRING .)
    MINUS           reduce using rule 20 (factor -> STRING .)
    TIMES           reduce using rule 20 (factor -> STRING .)
    DIVIDE          reduce using rule 20 (factor -> STRING .)
    PIPE            reduce using rule 20 (factor -> STRING .)
    $end            reduce using rule 20 (factor -> STRING .)
    RPAREN          reduce using rule 20 (factor -> STRING .)
    DO              reduce using rule 20 (factor -> STRING .)
    THEN            reduce using rule 20 (factor -> STRING .)
    RCBRACE         reduce using rule 20 (factor -> STRING .)
    COMMA           reduce using rule 20 (factor -> STRING .)
    IN              reduce using rule 20 (factor -> STRING .)
    ELSE            reduce using rule 20 (factor -> STRING .)


state 22

    (21) factor -> NUMBER .

    PLUS            reduce using rule 21 (factor -> NUMBER .)
    MINUS           reduce using rule 21 (factor -> NUMBER .)
    TIMES           reduce using rule 21 (factor -> NUMBER .)
    DIVIDE          reduce using rule 21 (factor -> NUMBER .)
    PIPE            reduce using rule 21 (factor -> NUMBER .)
    $end            reduce using rule 21 (factor -> NUMBER .)
    RPAREN          reduce using rule 21 (factor -> NUMBER .)
    DO              reduce using rule 21 (factor -> NUMBER .)
    THEN            reduce using rule 21 (factor -> NUMBER .)
    RCBRACE         reduce using rule 21 (factor -> NUMBER .)
    COMMA           reduce using rule 21 (factor -> NUMBER .)
    IN              reduce using rule 21 (factor -> NUMBER .)
    ELSE            reduce using rule 21 (factor -> NUMBER .)


state 23

    (22) factor -> TRUE .

    PLUS            reduce using rule 22 (factor -> TRUE .)
    MINUS           reduce using rule 22 (factor -> TRUE .)
    TIMES           reduce using rule 22 (factor -> TRUE .)
    DIVIDE          reduce using rule 22 (factor -> TRUE .)
    PIPE            reduce using rule 22 (factor -> TRUE .)
    $end            reduce using rule 22 (factor -> TRUE .)
    RPAREN          reduce using rule 22 (factor -> TRUE .)
    DO              reduce using rule 22 (factor -> TRUE .)
    THEN            reduce using rule 22 (factor -> TRUE .)
    RCBRACE         reduce using rule 22 (factor -> TRUE .)
    COMMA           reduce using rule 22 (factor -> TRUE .)
    IN              reduce using rule 22 (factor -> TRUE .)
    ELSE            reduce using rule 22 (factor -> TRUE .)


state 24

    (23) factor -> FALSE .

    PLUS            reduce using rule 23 (factor -> FALSE .)
    MINUS           reduce using rule 23 (factor -> FALSE .)
    TIMES           reduce using rule 23 (factor -> FALSE .)
    DIVIDE          reduce using rule 23 (factor -> FALSE .)
    PIPE            reduce using rule 23 (factor -> FALSE .)
    $end            reduce using rule 23 (factor -> FALSE .)
    RPAREN          reduce using rule 23 (factor -> FALSE .)
    DO              reduce using rule 23 (factor -> FALSE .)
    THEN            reduce using rule 23 (factor -> FALSE .)
    RCBRACE         reduce using rule 23 (factor -> FALSE .)
    COMMA           reduce using rule 23 (factor -> FALSE .)
    IN              reduce using rule 23 (factor -> FALSE .)
    ELSE            reduce using rule 23 (factor -> FALSE .)


state 25

    (1) program -> definitions imports . expression
    (16) imports -> imports . import
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (14) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IMPORT          shift and go to state 19
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 47
    import                         shift and go to state 29
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 26

    (3) program -> definitions expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    $end            reduce using rule 3 (program -> definitions expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 27

    (35) definitions -> definitions function_definition .

    LET             reduce using rule 35 (definitions -> definitions function_definition .)
    MINUS           reduce using rule 35 (definitions -> definitions function_definition .)
    LPAREN          reduce using rule 35 (definitions -> definitions function_definition .)
    WHILE           reduce using rule 35 (definitions -> definitions function_definition .)
    IF              reduce using rule 35 (definitions -> definitions function_definition .)
    LAZY            reduce using rule 35 (definitions -> definitions function_definition .)
    LCBRACE         reduce using rule 35 (definitions -> definitions function_definition .)
    LAMBDA          reduce using rule 35 (definitions -> definitions function_definition .)
    FUNC            reduce using rule 35 (definitions -> definitions function_definition .)
    IMPORT          reduce using rule 35 (definitions -> definitions function_definition .)
    IDENTIFIER      reduce using rule 35 (definitions -> definitions function_definition .)
    STRING          reduce using rule 35 (definitions -> definitions function_definition .)
    NUMBER          reduce using rule 35 (definitions -> definitions function_definition .)
    TRUE            reduce using rule 35 (definitions -> definitions function_definition .)
    FALSE           reduce using rule 35 (definitions -> definitions function_definition .)
    $end            reduce using rule 35 (definitions -> definitions function_definition .)


state 28

    (2) program -> imports expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    $end            reduce using rule 2 (program -> imports expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 29

    (16) imports -> imports import .

    LET             reduce using rule 16 (imports -> imports import .)
    MINUS           reduce using rule 16 (imports -> imports import .)
    LPAREN          reduce using rule 16 (imports -> imports import .)
    WHILE           reduce using rule 16 (imports -> imports import .)
    IF              reduce using rule 16 (imports -> imports import .)
    LAZY            reduce using rule 16 (imports -> imports import .)
    LCBRACE         reduce using rule 16 (imports -> imports import .)
    LAMBDA          reduce using rule 16 (imports -> imports import .)
    IMPORT          reduce using rule 16 (imports -> imports import .)
    IDENTIFIER      reduce using rule 16 (imports -> imports import .)
    STRING          reduce using rule 16 (imports -> imports import .)
    NUMBER          reduce using rule 16 (imports -> imports import .)
    TRUE            reduce using rule 16 (imports -> imports import .)
    FALSE           reduce using rule 16 (imports -> imports import .)
    $end            reduce using rule 16 (imports -> imports import .)


state 30

    (8) expression -> expression PLUS . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 48
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 31

    (9) expression -> expression MINUS . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 49
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 32

    (10) expression -> expression TIMES . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 50
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 33

    (11) expression -> expression DIVIDE . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 51
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 34

    (30) expression -> expression PIPE . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 52
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 35

    (7) expression -> LET IDENTIFIER . EQUALS expression IN expression

    EQUALS          shift and go to state 53


state 36

    (37) function_call -> IDENTIFIER LPAREN . args RPAREN
    (39) args -> . args COMMA arg
    (40) args -> . arg
    (41) args -> .
    (42) arg -> . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    RPAREN          reduce using rule 41 (args -> .)
    COMMA           reduce using rule 41 (args -> .)
    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    args                           shift and go to state 54
    arg                            shift and go to state 55
    expression                     shift and go to state 56
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 37

    (17) expression -> MINUS expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    PLUS            reduce using rule 17 (expression -> MINUS expression .)
    MINUS           reduce using rule 17 (expression -> MINUS expression .)
    TIMES           reduce using rule 17 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 17 (expression -> MINUS expression .)
    PIPE            reduce using rule 17 (expression -> MINUS expression .)
    $end            reduce using rule 17 (expression -> MINUS expression .)
    RPAREN          reduce using rule 17 (expression -> MINUS expression .)
    DO              reduce using rule 17 (expression -> MINUS expression .)
    THEN            reduce using rule 17 (expression -> MINUS expression .)
    RCBRACE         reduce using rule 17 (expression -> MINUS expression .)
    COMMA           reduce using rule 17 (expression -> MINUS expression .)
    IN              reduce using rule 17 (expression -> MINUS expression .)
    ELSE            reduce using rule 17 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! TIMES           [ shift and go to state 32 ]
  ! DIVIDE          [ shift and go to state 33 ]
  ! PIPE            [ shift and go to state 34 ]


state 38

    (18) expression -> LPAREN expression . RPAREN
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    RPAREN          shift and go to state 57
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 39

    (24) expression -> WHILE expression . DO expression
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    DO              shift and go to state 58
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 40

    (25) expression -> IF expression . THEN expression ELSE expression
    (26) expression -> IF expression . THEN expression
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    THEN            shift and go to state 59
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 41

    (27) expression -> LAZY expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 27 (expression -> LAZY expression .)
    RPAREN          reduce using rule 27 (expression -> LAZY expression .)
    DO              reduce using rule 27 (expression -> LAZY expression .)
    THEN            reduce using rule 27 (expression -> LAZY expression .)
    RCBRACE         reduce using rule 27 (expression -> LAZY expression .)
    COMMA           reduce using rule 27 (expression -> LAZY expression .)
    IN              reduce using rule 27 (expression -> LAZY expression .)
    ELSE            reduce using rule 27 (expression -> LAZY expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34

  ! PLUS            [ reduce using rule 27 (expression -> LAZY expression .) ]
  ! MINUS           [ reduce using rule 27 (expression -> LAZY expression .) ]
  ! TIMES           [ reduce using rule 27 (expression -> LAZY expression .) ]
  ! DIVIDE          [ reduce using rule 27 (expression -> LAZY expression .) ]
  ! PIPE            [ reduce using rule 27 (expression -> LAZY expression .) ]


state 42

    (28) expression -> LCBRACE expression . RCBRACE
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    RCBRACE         shift and go to state 60
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 43

    (29) expression -> LAMBDA LPAREN . args RPAREN expression
    (39) args -> . args COMMA arg
    (40) args -> . arg
    (41) args -> .
    (42) arg -> . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    RPAREN          reduce using rule 41 (args -> .)
    COMMA           reduce using rule 41 (args -> .)
    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    args                           shift and go to state 61
    expression                     shift and go to state 56
    arg                            shift and go to state 55
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 44

    (36) function_call -> function_call LPAREN . args RPAREN
    (39) args -> . args COMMA arg
    (40) args -> . arg
    (41) args -> .
    (42) arg -> . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    RPAREN          reduce using rule 41 (args -> .)
    COMMA           reduce using rule 41 (args -> .)
    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    function_call                  shift and go to state 16
    args                           shift and go to state 62
    arg                            shift and go to state 55
    expression                     shift and go to state 56
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 45

    (33) function_definition -> FUNC IDENTIFIER . LPAREN args RPAREN LCBRACE expression RCBRACE

    LPAREN          shift and go to state 63


state 46

    (14) import -> IMPORT IDENTIFIER . AS IDENTIFIER

    AS              shift and go to state 64


state 47

    (1) program -> definitions imports expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    $end            reduce using rule 1 (program -> definitions imports expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 48

    (8) expression -> expression PLUS expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    PLUS            reduce using rule 8 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 8 (expression -> expression PLUS expression .)
    PIPE            reduce using rule 8 (expression -> expression PLUS expression .)
    $end            reduce using rule 8 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 8 (expression -> expression PLUS expression .)
    DO              reduce using rule 8 (expression -> expression PLUS expression .)
    THEN            reduce using rule 8 (expression -> expression PLUS expression .)
    RCBRACE         reduce using rule 8 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 8 (expression -> expression PLUS expression .)
    IN              reduce using rule 8 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 8 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33

  ! TIMES           [ reduce using rule 8 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 8 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! PIPE            [ shift and go to state 34 ]


state 49

    (9) expression -> expression MINUS expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    PLUS            reduce using rule 9 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 9 (expression -> expression MINUS expression .)
    PIPE            reduce using rule 9 (expression -> expression MINUS expression .)
    $end            reduce using rule 9 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 9 (expression -> expression MINUS expression .)
    DO              reduce using rule 9 (expression -> expression MINUS expression .)
    THEN            reduce using rule 9 (expression -> expression MINUS expression .)
    RCBRACE         reduce using rule 9 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 9 (expression -> expression MINUS expression .)
    IN              reduce using rule 9 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 9 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33

  ! TIMES           [ reduce using rule 9 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 9 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! PIPE            [ shift and go to state 34 ]


state 50

    (10) expression -> expression TIMES expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    PLUS            reduce using rule 10 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 10 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 10 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 10 (expression -> expression TIMES expression .)
    PIPE            reduce using rule 10 (expression -> expression TIMES expression .)
    $end            reduce using rule 10 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 10 (expression -> expression TIMES expression .)
    DO              reduce using rule 10 (expression -> expression TIMES expression .)
    THEN            reduce using rule 10 (expression -> expression TIMES expression .)
    RCBRACE         reduce using rule 10 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 10 (expression -> expression TIMES expression .)
    IN              reduce using rule 10 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 10 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! TIMES           [ shift and go to state 32 ]
  ! DIVIDE          [ shift and go to state 33 ]
  ! PIPE            [ shift and go to state 34 ]


state 51

    (11) expression -> expression DIVIDE expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    PLUS            reduce using rule 11 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 11 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 11 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 11 (expression -> expression DIVIDE expression .)
    PIPE            reduce using rule 11 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 11 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 11 (expression -> expression DIVIDE expression .)
    DO              reduce using rule 11 (expression -> expression DIVIDE expression .)
    THEN            reduce using rule 11 (expression -> expression DIVIDE expression .)
    RCBRACE         reduce using rule 11 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 11 (expression -> expression DIVIDE expression .)
    IN              reduce using rule 11 (expression -> expression DIVIDE expression .)
    ELSE            reduce using rule 11 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! TIMES           [ shift and go to state 32 ]
  ! DIVIDE          [ shift and go to state 33 ]
  ! PIPE            [ shift and go to state 34 ]


state 52

    (30) expression -> expression PIPE expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    PIPE            reduce using rule 30 (expression -> expression PIPE expression .)
    $end            reduce using rule 30 (expression -> expression PIPE expression .)
    RPAREN          reduce using rule 30 (expression -> expression PIPE expression .)
    DO              reduce using rule 30 (expression -> expression PIPE expression .)
    THEN            reduce using rule 30 (expression -> expression PIPE expression .)
    RCBRACE         reduce using rule 30 (expression -> expression PIPE expression .)
    COMMA           reduce using rule 30 (expression -> expression PIPE expression .)
    IN              reduce using rule 30 (expression -> expression PIPE expression .)
    ELSE            reduce using rule 30 (expression -> expression PIPE expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33

  ! PLUS            [ reduce using rule 30 (expression -> expression PIPE expression .) ]
  ! MINUS           [ reduce using rule 30 (expression -> expression PIPE expression .) ]
  ! TIMES           [ reduce using rule 30 (expression -> expression PIPE expression .) ]
  ! DIVIDE          [ reduce using rule 30 (expression -> expression PIPE expression .) ]
  ! PIPE            [ shift and go to state 34 ]


state 53

    (7) expression -> LET IDENTIFIER EQUALS . expression IN expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 65
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 54

    (37) function_call -> IDENTIFIER LPAREN args . RPAREN
    (39) args -> args . COMMA arg

    RPAREN          shift and go to state 66
    COMMA           shift and go to state 67


state 55

    (40) args -> arg .

    RPAREN          reduce using rule 40 (args -> arg .)
    COMMA           reduce using rule 40 (args -> arg .)


state 56

    (42) arg -> expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    RPAREN          reduce using rule 42 (arg -> expression .)
    COMMA           reduce using rule 42 (arg -> expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 57

    (18) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    PIPE            reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    DO              reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    THEN            reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    RCBRACE         reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    IN              reduce using rule 18 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 18 (expression -> LPAREN expression RPAREN .)


state 58

    (24) expression -> WHILE expression DO . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 68
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 59

    (25) expression -> IF expression THEN . expression ELSE expression
    (26) expression -> IF expression THEN . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 69
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 60

    (28) expression -> LCBRACE expression RCBRACE .

    PLUS            reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    MINUS           reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    TIMES           reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    DIVIDE          reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    PIPE            reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    $end            reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    RPAREN          reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    DO              reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    THEN            reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    RCBRACE         reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    COMMA           reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    IN              reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)
    ELSE            reduce using rule 28 (expression -> LCBRACE expression RCBRACE .)


state 61

    (29) expression -> LAMBDA LPAREN args . RPAREN expression
    (39) args -> args . COMMA arg

    RPAREN          shift and go to state 70
    COMMA           shift and go to state 67


state 62

    (36) function_call -> function_call LPAREN args . RPAREN
    (39) args -> args . COMMA arg

    RPAREN          shift and go to state 71
    COMMA           shift and go to state 67


state 63

    (33) function_definition -> FUNC IDENTIFIER LPAREN . args RPAREN LCBRACE expression RCBRACE
    (39) args -> . args COMMA arg
    (40) args -> . arg
    (41) args -> .
    (42) arg -> . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    RPAREN          reduce using rule 41 (args -> .)
    COMMA           reduce using rule 41 (args -> .)
    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    args                           shift and go to state 72
    expression                     shift and go to state 56
    arg                            shift and go to state 55
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 64

    (14) import -> IMPORT IDENTIFIER AS . IDENTIFIER

    IDENTIFIER      shift and go to state 73


state 65

    (7) expression -> LET IDENTIFIER EQUALS expression . IN expression
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    IN              shift and go to state 74
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 66

    (37) function_call -> IDENTIFIER LPAREN args RPAREN .

    LPAREN          reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    PLUS            reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    MINUS           reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    TIMES           reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    DIVIDE          reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    PIPE            reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    $end            reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    RPAREN          reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    DO              reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    THEN            reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    RCBRACE         reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    COMMA           reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    IN              reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    ELSE            reduce using rule 37 (function_call -> IDENTIFIER LPAREN args RPAREN .)


state 67

    (39) args -> args COMMA . arg
    (42) arg -> . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    arg                            shift and go to state 75
    expression                     shift and go to state 56
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 68

    (24) expression -> WHILE expression DO expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 24 (expression -> WHILE expression DO expression .)
    RPAREN          reduce using rule 24 (expression -> WHILE expression DO expression .)
    DO              reduce using rule 24 (expression -> WHILE expression DO expression .)
    THEN            reduce using rule 24 (expression -> WHILE expression DO expression .)
    RCBRACE         reduce using rule 24 (expression -> WHILE expression DO expression .)
    COMMA           reduce using rule 24 (expression -> WHILE expression DO expression .)
    IN              reduce using rule 24 (expression -> WHILE expression DO expression .)
    ELSE            reduce using rule 24 (expression -> WHILE expression DO expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34

  ! PLUS            [ reduce using rule 24 (expression -> WHILE expression DO expression .) ]
  ! MINUS           [ reduce using rule 24 (expression -> WHILE expression DO expression .) ]
  ! TIMES           [ reduce using rule 24 (expression -> WHILE expression DO expression .) ]
  ! DIVIDE          [ reduce using rule 24 (expression -> WHILE expression DO expression .) ]
  ! PIPE            [ reduce using rule 24 (expression -> WHILE expression DO expression .) ]


state 69

    (25) expression -> IF expression THEN expression . ELSE expression
    (26) expression -> IF expression THEN expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    ELSE            shift and go to state 76
    $end            reduce using rule 26 (expression -> IF expression THEN expression .)
    RPAREN          reduce using rule 26 (expression -> IF expression THEN expression .)
    DO              reduce using rule 26 (expression -> IF expression THEN expression .)
    THEN            reduce using rule 26 (expression -> IF expression THEN expression .)
    RCBRACE         reduce using rule 26 (expression -> IF expression THEN expression .)
    COMMA           reduce using rule 26 (expression -> IF expression THEN expression .)
    IN              reduce using rule 26 (expression -> IF expression THEN expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34

  ! PLUS            [ reduce using rule 26 (expression -> IF expression THEN expression .) ]
  ! MINUS           [ reduce using rule 26 (expression -> IF expression THEN expression .) ]
  ! TIMES           [ reduce using rule 26 (expression -> IF expression THEN expression .) ]
  ! DIVIDE          [ reduce using rule 26 (expression -> IF expression THEN expression .) ]
  ! PIPE            [ reduce using rule 26 (expression -> IF expression THEN expression .) ]
  ! ELSE            [ reduce using rule 26 (expression -> IF expression THEN expression .) ]


state 70

    (29) expression -> LAMBDA LPAREN args RPAREN . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 77
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 71

    (36) function_call -> function_call LPAREN args RPAREN .

    LPAREN          reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    PLUS            reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    MINUS           reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    TIMES           reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    DIVIDE          reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    PIPE            reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    $end            reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    RPAREN          reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    DO              reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    THEN            reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    RCBRACE         reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    COMMA           reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    IN              reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)
    ELSE            reduce using rule 36 (function_call -> function_call LPAREN args RPAREN .)


state 72

    (33) function_definition -> FUNC IDENTIFIER LPAREN args . RPAREN LCBRACE expression RCBRACE
    (39) args -> args . COMMA arg

    RPAREN          shift and go to state 78
    COMMA           shift and go to state 67


state 73

    (14) import -> IMPORT IDENTIFIER AS IDENTIFIER .

    LET             reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    MINUS           reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LPAREN          reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    WHILE           reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IF              reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LAZY            reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LCBRACE         reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LAMBDA          reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IMPORT          reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IDENTIFIER      reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    STRING          reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    NUMBER          reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    TRUE            reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    FALSE           reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    $end            reduce using rule 14 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)


state 74

    (7) expression -> LET IDENTIFIER EQUALS expression IN . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 79
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 75

    (39) args -> args COMMA arg .

    RPAREN          reduce using rule 39 (args -> args COMMA arg .)
    COMMA           reduce using rule 39 (args -> args COMMA arg .)


state 76

    (25) expression -> IF expression THEN expression ELSE . expression
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 80
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 77

    (29) expression -> LAMBDA LPAREN args RPAREN expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    RPAREN          reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    DO              reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    THEN            reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    RCBRACE         reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    COMMA           reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    IN              reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    ELSE            reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34

  ! PLUS            [ reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .) ]
  ! MINUS           [ reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .) ]
  ! TIMES           [ reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .) ]
  ! DIVIDE          [ reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .) ]
  ! PIPE            [ reduce using rule 29 (expression -> LAMBDA LPAREN args RPAREN expression .) ]


state 78

    (33) function_definition -> FUNC IDENTIFIER LPAREN args RPAREN . LCBRACE expression RCBRACE

    LCBRACE         shift and go to state 81


state 79

    (7) expression -> LET IDENTIFIER EQUALS expression IN expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    RPAREN          reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    DO              reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    THEN            reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    RCBRACE         reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    COMMA           reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    IN              reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    ELSE            reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34

  ! PLUS            [ reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! MINUS           [ reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! TIMES           [ reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! DIVIDE          [ reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! PIPE            [ reduce using rule 7 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]


state 80

    (25) expression -> IF expression THEN expression ELSE expression .
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    RPAREN          reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    DO              reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    THEN            reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    RCBRACE         reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    COMMA           reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    IN              reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    ELSE            reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34

  ! PLUS            [ reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .) ]
  ! MINUS           [ reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .) ]
  ! TIMES           [ reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .) ]
  ! DIVIDE          [ reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .) ]
  ! PIPE            [ reduce using rule 25 (expression -> IF expression THEN expression ELSE expression .) ]


state 81

    (33) function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE . expression RCBRACE
    (7) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (8) expression -> . expression PLUS expression
    (9) expression -> . expression MINUS expression
    (10) expression -> . expression TIMES expression
    (11) expression -> . expression DIVIDE expression
    (17) expression -> . MINUS expression
    (18) expression -> . LPAREN expression RPAREN
    (24) expression -> . WHILE expression DO expression
    (25) expression -> . IF expression THEN expression ELSE expression
    (26) expression -> . IF expression THEN expression
    (27) expression -> . LAZY expression
    (28) expression -> . LCBRACE expression RCBRACE
    (29) expression -> . LAMBDA LPAREN args RPAREN expression
    (30) expression -> . expression PIPE expression
    (31) expression -> . function_call
    (32) expression -> . term
    (36) function_call -> . function_call LPAREN args RPAREN
    (37) function_call -> . IDENTIFIER LPAREN args RPAREN
    (38) function_call -> . IDENTIFIER
    (19) term -> . factor
    (20) factor -> . STRING
    (21) factor -> . NUMBER
    (22) factor -> . TRUE
    (23) factor -> . FALSE

    LET             shift and go to state 7
    MINUS           shift and go to state 9
    LPAREN          shift and go to state 10
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    LAZY            shift and go to state 13
    LCBRACE         shift and go to state 14
    LAMBDA          shift and go to state 15
    IDENTIFIER      shift and go to state 8
    STRING          shift and go to state 21
    NUMBER          shift and go to state 22
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24

    expression                     shift and go to state 82
    function_call                  shift and go to state 16
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 82

    (33) function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression . RCBRACE
    (8) expression -> expression . PLUS expression
    (9) expression -> expression . MINUS expression
    (10) expression -> expression . TIMES expression
    (11) expression -> expression . DIVIDE expression
    (30) expression -> expression . PIPE expression

    RCBRACE         shift and go to state 83
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    DIVIDE          shift and go to state 33
    PIPE            shift and go to state 34


state 83

    (33) function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .

    LET             reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    MINUS           reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    LPAREN          reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    WHILE           reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    IF              reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    LAZY            reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    LCBRACE         reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    LAMBDA          reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    FUNC            reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    IMPORT          reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    IDENTIFIER      reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    STRING          reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    NUMBER          reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    TRUE            reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    FALSE           reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)
    $end            reduce using rule 33 (function_definition -> FUNC IDENTIFIER LPAREN args RPAREN LCBRACE expression RCBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 8 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 41 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 41 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 41 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 68 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 68 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 69 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 77 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 77 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 79 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 80 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 80 resolved as shift
