Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BOOLEAN
    BOOLEANCAST
    CATCH
    DEF
    DOT
    DOUBLECAST
    EMPTY
    EQUALITY
    FINALLY
    FOREACH
    FUNC
    GREATER
    GREATEREQUAL
    HEAD
    IMPLIES
    INTEGERCAST
    LBRACK
    LEN
    LESS
    LESSEQUAL
    NAMESPACE_OP
    NOT
    NULL
    OR
    RBRACK
    STRINGCAST
    TAIL
    TRY

Grammar

Rule 0     S' -> program
Rule 1     program -> imports expression
Rule 2     program -> expression
Rule 3     import -> IMPORT IDENTIFIER AS IDENTIFIER
Rule 4     imports -> import
Rule 5     imports -> imports import
Rule 6     expression -> LET IDENTIFIER EQUALS expression IN expression
Rule 7     expression -> expression PLUS expression
Rule 8     expression -> expression MINUS expression
Rule 9     expression -> expression TIMES expression
Rule 10    expression -> expression DIVIDE expression
Rule 11    expression -> MINUS expression
Rule 12    expression -> LPAREN expression RPAREN
Rule 13    term -> factor
Rule 14    factor -> STRING
Rule 15    factor -> NUMBER
Rule 16    factor -> TRUE
Rule 17    factor -> FALSE
Rule 18    expression -> WHILE expression DO expression
Rule 19    expression -> IF expression THEN expression ELSE expression
Rule 20    expression -> IF expression THEN expression
Rule 21    expression -> LAZY expression
Rule 22    term -> LCBRACE term RCBRACE
Rule 23    lambda -> LAMBDA LPAREN args RPAREN expression
Rule 24    expression -> expression PIPE expression
Rule 25    expression -> function_call
Rule 26    expression -> lambda
Rule 27    expression -> term
Rule 28    function_call -> function_call LPAREN args RPAREN
Rule 29    function_call -> function_call LPAREN RPAREN
Rule 30    function_call -> lambda LPAREN args RPAREN
Rule 31    function_call -> IDENTIFIER
Rule 32    args -> args COMMA arg
Rule 33    args -> arg
Rule 34    args -> <empty>
Rule 35    arg -> expression

Terminals, with rules where they appear

AND                  : 
AS                   : 3
BOOLEAN              : 
BOOLEANCAST          : 
CATCH                : 
COMMA                : 32
DEF                  : 
DIVIDE               : 10
DO                   : 18
DOT                  : 
DOUBLECAST           : 
ELSE                 : 19
EMPTY                : 
EQUALITY             : 
EQUALS               : 6
FALSE                : 17
FINALLY              : 
FOREACH              : 
FUNC                 : 
GREATER              : 
GREATEREQUAL         : 
HEAD                 : 
IDENTIFIER           : 3 3 6 31
IF                   : 19 20
IMPLIES              : 
IMPORT               : 3
IN                   : 6
INTEGERCAST          : 
LAMBDA               : 23
LAZY                 : 21
LBRACK               : 
LCBRACE              : 22
LEN                  : 
LESS                 : 
LESSEQUAL            : 
LET                  : 6
LPAREN               : 12 23 28 29 30
MINUS                : 8 11
NAMESPACE_OP         : 
NOT                  : 
NULL                 : 
NUMBER               : 15
OR                   : 
PIPE                 : 24
PLUS                 : 7
RBRACK               : 
RCBRACE              : 22
RPAREN               : 12 23 28 29 30
STRING               : 14
STRINGCAST           : 
TAIL                 : 
THEN                 : 19 20
TIMES                : 9
TRUE                 : 16
TRY                  : 
WHILE                : 18
error                : 

Nonterminals, with rules where they appear

arg                  : 32 33
args                 : 23 28 30 32
expression           : 1 2 6 6 7 7 8 8 9 9 10 10 11 12 18 18 19 19 19 20 20 21 23 24 24 35
factor               : 13
function_call        : 25 28 29
import               : 4 5
imports              : 1 5
lambda               : 26 30
program              : 0
term                 : 22 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . imports expression
    (2) program -> . expression
    (4) imports -> . import
    (5) imports -> . imports import
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (3) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IMPORT          shift and go to state 15
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    program                        shift and go to state 1
    imports                        shift and go to state 2
    expression                     shift and go to state 3
    import                         shift and go to state 4
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 1

    (0) S' -> program .



state 2

    (1) program -> imports . expression
    (5) imports -> imports . import
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (3) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IMPORT          shift and go to state 15
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 23
    import                         shift and go to state 24
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 3

    (2) program -> expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    $end            reduce using rule 2 (program -> expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29


state 4

    (4) imports -> import .

    LET             reduce using rule 4 (imports -> import .)
    MINUS           reduce using rule 4 (imports -> import .)
    LPAREN          reduce using rule 4 (imports -> import .)
    WHILE           reduce using rule 4 (imports -> import .)
    IF              reduce using rule 4 (imports -> import .)
    LAZY            reduce using rule 4 (imports -> import .)
    IMPORT          reduce using rule 4 (imports -> import .)
    IDENTIFIER      reduce using rule 4 (imports -> import .)
    LAMBDA          reduce using rule 4 (imports -> import .)
    LCBRACE         reduce using rule 4 (imports -> import .)
    STRING          reduce using rule 4 (imports -> import .)
    NUMBER          reduce using rule 4 (imports -> import .)
    TRUE            reduce using rule 4 (imports -> import .)
    FALSE           reduce using rule 4 (imports -> import .)


state 5

    (6) expression -> LET . IDENTIFIER EQUALS expression IN expression

    IDENTIFIER      shift and go to state 30


state 6

    (31) function_call -> IDENTIFIER .

    LPAREN          reduce using rule 31 (function_call -> IDENTIFIER .)
    PLUS            reduce using rule 31 (function_call -> IDENTIFIER .)
    MINUS           reduce using rule 31 (function_call -> IDENTIFIER .)
    TIMES           reduce using rule 31 (function_call -> IDENTIFIER .)
    DIVIDE          reduce using rule 31 (function_call -> IDENTIFIER .)
    PIPE            reduce using rule 31 (function_call -> IDENTIFIER .)
    $end            reduce using rule 31 (function_call -> IDENTIFIER .)
    RPAREN          reduce using rule 31 (function_call -> IDENTIFIER .)
    DO              reduce using rule 31 (function_call -> IDENTIFIER .)
    THEN            reduce using rule 31 (function_call -> IDENTIFIER .)
    COMMA           reduce using rule 31 (function_call -> IDENTIFIER .)
    IN              reduce using rule 31 (function_call -> IDENTIFIER .)
    ELSE            reduce using rule 31 (function_call -> IDENTIFIER .)


state 7

    (11) expression -> MINUS . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 31
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 8

    (12) expression -> LPAREN . expression RPAREN
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 32
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 9

    (18) expression -> WHILE . expression DO expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 33
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 10

    (19) expression -> IF . expression THEN expression ELSE expression
    (20) expression -> IF . expression THEN expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 34
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 11

    (21) expression -> LAZY . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 35
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 12

    (25) expression -> function_call .
    (28) function_call -> function_call . LPAREN args RPAREN
    (29) function_call -> function_call . LPAREN RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    PLUS            reduce using rule 25 (expression -> function_call .)
    MINUS           reduce using rule 25 (expression -> function_call .)
    TIMES           reduce using rule 25 (expression -> function_call .)
    DIVIDE          reduce using rule 25 (expression -> function_call .)
    PIPE            reduce using rule 25 (expression -> function_call .)
    $end            reduce using rule 25 (expression -> function_call .)
    RPAREN          reduce using rule 25 (expression -> function_call .)
    DO              reduce using rule 25 (expression -> function_call .)
    THEN            reduce using rule 25 (expression -> function_call .)
    COMMA           reduce using rule 25 (expression -> function_call .)
    IN              reduce using rule 25 (expression -> function_call .)
    ELSE            reduce using rule 25 (expression -> function_call .)
    LPAREN          shift and go to state 36

  ! LPAREN          [ reduce using rule 25 (expression -> function_call .) ]


state 13

    (26) expression -> lambda .
    (30) function_call -> lambda . LPAREN args RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    PLUS            reduce using rule 26 (expression -> lambda .)
    MINUS           reduce using rule 26 (expression -> lambda .)
    TIMES           reduce using rule 26 (expression -> lambda .)
    DIVIDE          reduce using rule 26 (expression -> lambda .)
    PIPE            reduce using rule 26 (expression -> lambda .)
    $end            reduce using rule 26 (expression -> lambda .)
    RPAREN          reduce using rule 26 (expression -> lambda .)
    DO              reduce using rule 26 (expression -> lambda .)
    THEN            reduce using rule 26 (expression -> lambda .)
    COMMA           reduce using rule 26 (expression -> lambda .)
    IN              reduce using rule 26 (expression -> lambda .)
    ELSE            reduce using rule 26 (expression -> lambda .)
    LPAREN          shift and go to state 37

  ! LPAREN          [ reduce using rule 26 (expression -> lambda .) ]


state 14

    (27) expression -> term .

    PLUS            reduce using rule 27 (expression -> term .)
    MINUS           reduce using rule 27 (expression -> term .)
    TIMES           reduce using rule 27 (expression -> term .)
    DIVIDE          reduce using rule 27 (expression -> term .)
    PIPE            reduce using rule 27 (expression -> term .)
    $end            reduce using rule 27 (expression -> term .)
    RPAREN          reduce using rule 27 (expression -> term .)
    DO              reduce using rule 27 (expression -> term .)
    THEN            reduce using rule 27 (expression -> term .)
    COMMA           reduce using rule 27 (expression -> term .)
    IN              reduce using rule 27 (expression -> term .)
    ELSE            reduce using rule 27 (expression -> term .)
    LPAREN          reduce using rule 27 (expression -> term .)


state 15

    (3) import -> IMPORT . IDENTIFIER AS IDENTIFIER

    IDENTIFIER      shift and go to state 38


state 16

    (23) lambda -> LAMBDA . LPAREN args RPAREN expression

    LPAREN          shift and go to state 39


state 17

    (13) term -> factor .

    PLUS            reduce using rule 13 (term -> factor .)
    MINUS           reduce using rule 13 (term -> factor .)
    TIMES           reduce using rule 13 (term -> factor .)
    DIVIDE          reduce using rule 13 (term -> factor .)
    PIPE            reduce using rule 13 (term -> factor .)
    $end            reduce using rule 13 (term -> factor .)
    RPAREN          reduce using rule 13 (term -> factor .)
    DO              reduce using rule 13 (term -> factor .)
    THEN            reduce using rule 13 (term -> factor .)
    COMMA           reduce using rule 13 (term -> factor .)
    IN              reduce using rule 13 (term -> factor .)
    ELSE            reduce using rule 13 (term -> factor .)
    LPAREN          reduce using rule 13 (term -> factor .)
    RCBRACE         reduce using rule 13 (term -> factor .)


state 18

    (22) term -> LCBRACE . term RCBRACE
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    term                           shift and go to state 40
    factor                         shift and go to state 17

state 19

    (14) factor -> STRING .

    PLUS            reduce using rule 14 (factor -> STRING .)
    MINUS           reduce using rule 14 (factor -> STRING .)
    TIMES           reduce using rule 14 (factor -> STRING .)
    DIVIDE          reduce using rule 14 (factor -> STRING .)
    PIPE            reduce using rule 14 (factor -> STRING .)
    $end            reduce using rule 14 (factor -> STRING .)
    RPAREN          reduce using rule 14 (factor -> STRING .)
    DO              reduce using rule 14 (factor -> STRING .)
    THEN            reduce using rule 14 (factor -> STRING .)
    COMMA           reduce using rule 14 (factor -> STRING .)
    IN              reduce using rule 14 (factor -> STRING .)
    ELSE            reduce using rule 14 (factor -> STRING .)
    LPAREN          reduce using rule 14 (factor -> STRING .)
    RCBRACE         reduce using rule 14 (factor -> STRING .)


state 20

    (15) factor -> NUMBER .

    PLUS            reduce using rule 15 (factor -> NUMBER .)
    MINUS           reduce using rule 15 (factor -> NUMBER .)
    TIMES           reduce using rule 15 (factor -> NUMBER .)
    DIVIDE          reduce using rule 15 (factor -> NUMBER .)
    PIPE            reduce using rule 15 (factor -> NUMBER .)
    $end            reduce using rule 15 (factor -> NUMBER .)
    RPAREN          reduce using rule 15 (factor -> NUMBER .)
    DO              reduce using rule 15 (factor -> NUMBER .)
    THEN            reduce using rule 15 (factor -> NUMBER .)
    COMMA           reduce using rule 15 (factor -> NUMBER .)
    IN              reduce using rule 15 (factor -> NUMBER .)
    ELSE            reduce using rule 15 (factor -> NUMBER .)
    LPAREN          reduce using rule 15 (factor -> NUMBER .)
    RCBRACE         reduce using rule 15 (factor -> NUMBER .)


state 21

    (16) factor -> TRUE .

    PLUS            reduce using rule 16 (factor -> TRUE .)
    MINUS           reduce using rule 16 (factor -> TRUE .)
    TIMES           reduce using rule 16 (factor -> TRUE .)
    DIVIDE          reduce using rule 16 (factor -> TRUE .)
    PIPE            reduce using rule 16 (factor -> TRUE .)
    $end            reduce using rule 16 (factor -> TRUE .)
    RPAREN          reduce using rule 16 (factor -> TRUE .)
    DO              reduce using rule 16 (factor -> TRUE .)
    THEN            reduce using rule 16 (factor -> TRUE .)
    COMMA           reduce using rule 16 (factor -> TRUE .)
    IN              reduce using rule 16 (factor -> TRUE .)
    ELSE            reduce using rule 16 (factor -> TRUE .)
    LPAREN          reduce using rule 16 (factor -> TRUE .)
    RCBRACE         reduce using rule 16 (factor -> TRUE .)


state 22

    (17) factor -> FALSE .

    PLUS            reduce using rule 17 (factor -> FALSE .)
    MINUS           reduce using rule 17 (factor -> FALSE .)
    TIMES           reduce using rule 17 (factor -> FALSE .)
    DIVIDE          reduce using rule 17 (factor -> FALSE .)
    PIPE            reduce using rule 17 (factor -> FALSE .)
    $end            reduce using rule 17 (factor -> FALSE .)
    RPAREN          reduce using rule 17 (factor -> FALSE .)
    DO              reduce using rule 17 (factor -> FALSE .)
    THEN            reduce using rule 17 (factor -> FALSE .)
    COMMA           reduce using rule 17 (factor -> FALSE .)
    IN              reduce using rule 17 (factor -> FALSE .)
    ELSE            reduce using rule 17 (factor -> FALSE .)
    LPAREN          reduce using rule 17 (factor -> FALSE .)
    RCBRACE         reduce using rule 17 (factor -> FALSE .)


state 23

    (1) program -> imports expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    $end            reduce using rule 1 (program -> imports expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29


state 24

    (5) imports -> imports import .

    LET             reduce using rule 5 (imports -> imports import .)
    MINUS           reduce using rule 5 (imports -> imports import .)
    LPAREN          reduce using rule 5 (imports -> imports import .)
    WHILE           reduce using rule 5 (imports -> imports import .)
    IF              reduce using rule 5 (imports -> imports import .)
    LAZY            reduce using rule 5 (imports -> imports import .)
    IMPORT          reduce using rule 5 (imports -> imports import .)
    IDENTIFIER      reduce using rule 5 (imports -> imports import .)
    LAMBDA          reduce using rule 5 (imports -> imports import .)
    LCBRACE         reduce using rule 5 (imports -> imports import .)
    STRING          reduce using rule 5 (imports -> imports import .)
    NUMBER          reduce using rule 5 (imports -> imports import .)
    TRUE            reduce using rule 5 (imports -> imports import .)
    FALSE           reduce using rule 5 (imports -> imports import .)


state 25

    (7) expression -> expression PLUS . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 41
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 26

    (8) expression -> expression MINUS . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 42
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 27

    (9) expression -> expression TIMES . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 43
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 28

    (10) expression -> expression DIVIDE . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 44
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 29

    (24) expression -> expression PIPE . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 45
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 30

    (6) expression -> LET IDENTIFIER . EQUALS expression IN expression

    EQUALS          shift and go to state 46


state 31

    (11) expression -> MINUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PIPE            reduce using rule 11 (expression -> MINUS expression .)
    $end            reduce using rule 11 (expression -> MINUS expression .)
    RPAREN          reduce using rule 11 (expression -> MINUS expression .)
    DO              reduce using rule 11 (expression -> MINUS expression .)
    THEN            reduce using rule 11 (expression -> MINUS expression .)
    COMMA           reduce using rule 11 (expression -> MINUS expression .)
    IN              reduce using rule 11 (expression -> MINUS expression .)
    ELSE            reduce using rule 11 (expression -> MINUS expression .)
    LPAREN          reduce using rule 11 (expression -> MINUS expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28

  ! PLUS            [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! TIMES           [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! PIPE            [ shift and go to state 29 ]


state 32

    (12) expression -> LPAREN expression . RPAREN
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    RPAREN          shift and go to state 47
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29


state 33

    (18) expression -> WHILE expression . DO expression
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    DO              shift and go to state 48
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29


state 34

    (19) expression -> IF expression . THEN expression ELSE expression
    (20) expression -> IF expression . THEN expression
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    THEN            shift and go to state 49
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29


state 35

    (21) expression -> LAZY expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 21 (expression -> LAZY expression .)
    RPAREN          reduce using rule 21 (expression -> LAZY expression .)
    DO              reduce using rule 21 (expression -> LAZY expression .)
    THEN            reduce using rule 21 (expression -> LAZY expression .)
    COMMA           reduce using rule 21 (expression -> LAZY expression .)
    IN              reduce using rule 21 (expression -> LAZY expression .)
    ELSE            reduce using rule 21 (expression -> LAZY expression .)
    LPAREN          reduce using rule 21 (expression -> LAZY expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29

  ! PLUS            [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! MINUS           [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! TIMES           [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! DIVIDE          [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! PIPE            [ reduce using rule 21 (expression -> LAZY expression .) ]


state 36

    (28) function_call -> function_call LPAREN . args RPAREN
    (29) function_call -> function_call LPAREN . RPAREN
    (32) args -> . args COMMA arg
    (33) args -> . arg
    (34) args -> .
    (35) arg -> . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 51
    COMMA           reduce using rule 34 (args -> .)
    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

  ! RPAREN          [ reduce using rule 34 (args -> .) ]

    function_call                  shift and go to state 12
    args                           shift and go to state 50
    arg                            shift and go to state 52
    expression                     shift and go to state 53
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 37

    (30) function_call -> lambda LPAREN . args RPAREN
    (32) args -> . args COMMA arg
    (33) args -> . arg
    (34) args -> .
    (35) arg -> . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    RPAREN          reduce using rule 34 (args -> .)
    COMMA           reduce using rule 34 (args -> .)
    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    lambda                         shift and go to state 13
    args                           shift and go to state 54
    arg                            shift and go to state 52
    expression                     shift and go to state 53
    function_call                  shift and go to state 12
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 38

    (3) import -> IMPORT IDENTIFIER . AS IDENTIFIER

    AS              shift and go to state 55


state 39

    (23) lambda -> LAMBDA LPAREN . args RPAREN expression
    (32) args -> . args COMMA arg
    (33) args -> . arg
    (34) args -> .
    (35) arg -> . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    RPAREN          reduce using rule 34 (args -> .)
    COMMA           reduce using rule 34 (args -> .)
    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    args                           shift and go to state 56
    expression                     shift and go to state 53
    arg                            shift and go to state 52
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 40

    (22) term -> LCBRACE term . RCBRACE

    RCBRACE         shift and go to state 57


state 41

    (7) expression -> expression PLUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 7 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 7 (expression -> expression PLUS expression .)
    PIPE            reduce using rule 7 (expression -> expression PLUS expression .)
    $end            reduce using rule 7 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 7 (expression -> expression PLUS expression .)
    DO              reduce using rule 7 (expression -> expression PLUS expression .)
    THEN            reduce using rule 7 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 7 (expression -> expression PLUS expression .)
    IN              reduce using rule 7 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 7 (expression -> expression PLUS expression .)
    LPAREN          reduce using rule 7 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28

  ! TIMES           [ reduce using rule 7 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 7 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 25 ]
  ! MINUS           [ shift and go to state 26 ]
  ! PIPE            [ shift and go to state 29 ]


state 42

    (8) expression -> expression MINUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 8 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 8 (expression -> expression MINUS expression .)
    PIPE            reduce using rule 8 (expression -> expression MINUS expression .)
    $end            reduce using rule 8 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 8 (expression -> expression MINUS expression .)
    DO              reduce using rule 8 (expression -> expression MINUS expression .)
    THEN            reduce using rule 8 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 8 (expression -> expression MINUS expression .)
    IN              reduce using rule 8 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 8 (expression -> expression MINUS expression .)
    LPAREN          reduce using rule 8 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28

  ! TIMES           [ reduce using rule 8 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 8 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 25 ]
  ! MINUS           [ shift and go to state 26 ]
  ! PIPE            [ shift and go to state 29 ]


state 43

    (9) expression -> expression TIMES expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 9 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 9 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 9 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 9 (expression -> expression TIMES expression .)
    PIPE            reduce using rule 9 (expression -> expression TIMES expression .)
    $end            reduce using rule 9 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 9 (expression -> expression TIMES expression .)
    DO              reduce using rule 9 (expression -> expression TIMES expression .)
    THEN            reduce using rule 9 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 9 (expression -> expression TIMES expression .)
    IN              reduce using rule 9 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 9 (expression -> expression TIMES expression .)
    LPAREN          reduce using rule 9 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 25 ]
  ! MINUS           [ shift and go to state 26 ]
  ! TIMES           [ shift and go to state 27 ]
  ! DIVIDE          [ shift and go to state 28 ]
  ! PIPE            [ shift and go to state 29 ]


state 44

    (10) expression -> expression DIVIDE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 10 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 10 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 10 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 10 (expression -> expression DIVIDE expression .)
    PIPE            reduce using rule 10 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 10 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 10 (expression -> expression DIVIDE expression .)
    DO              reduce using rule 10 (expression -> expression DIVIDE expression .)
    THEN            reduce using rule 10 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 10 (expression -> expression DIVIDE expression .)
    IN              reduce using rule 10 (expression -> expression DIVIDE expression .)
    ELSE            reduce using rule 10 (expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 10 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 25 ]
  ! MINUS           [ shift and go to state 26 ]
  ! TIMES           [ shift and go to state 27 ]
  ! DIVIDE          [ shift and go to state 28 ]
  ! PIPE            [ shift and go to state 29 ]


state 45

    (24) expression -> expression PIPE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PIPE            reduce using rule 24 (expression -> expression PIPE expression .)
    $end            reduce using rule 24 (expression -> expression PIPE expression .)
    RPAREN          reduce using rule 24 (expression -> expression PIPE expression .)
    DO              reduce using rule 24 (expression -> expression PIPE expression .)
    THEN            reduce using rule 24 (expression -> expression PIPE expression .)
    COMMA           reduce using rule 24 (expression -> expression PIPE expression .)
    IN              reduce using rule 24 (expression -> expression PIPE expression .)
    ELSE            reduce using rule 24 (expression -> expression PIPE expression .)
    LPAREN          reduce using rule 24 (expression -> expression PIPE expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28

  ! PLUS            [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! MINUS           [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! TIMES           [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! DIVIDE          [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! PIPE            [ shift and go to state 29 ]


state 46

    (6) expression -> LET IDENTIFIER EQUALS . expression IN expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 58
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 47

    (12) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    PIPE            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    DO              reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    THEN            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    IN              reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 12 (expression -> LPAREN expression RPAREN .)


state 48

    (18) expression -> WHILE expression DO . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 59
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 49

    (19) expression -> IF expression THEN . expression ELSE expression
    (20) expression -> IF expression THEN . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 60
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 50

    (28) function_call -> function_call LPAREN args . RPAREN
    (32) args -> args . COMMA arg

    RPAREN          shift and go to state 61
    COMMA           shift and go to state 62


state 51

    (29) function_call -> function_call LPAREN RPAREN .

    LPAREN          reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    PLUS            reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    MINUS           reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    TIMES           reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    DIVIDE          reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    PIPE            reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    $end            reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    RPAREN          reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    DO              reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    THEN            reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    COMMA           reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    IN              reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)
    ELSE            reduce using rule 29 (function_call -> function_call LPAREN RPAREN .)


state 52

    (33) args -> arg .

    RPAREN          reduce using rule 33 (args -> arg .)
    COMMA           reduce using rule 33 (args -> arg .)


state 53

    (35) arg -> expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    RPAREN          reduce using rule 35 (arg -> expression .)
    COMMA           reduce using rule 35 (arg -> expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29


state 54

    (30) function_call -> lambda LPAREN args . RPAREN
    (32) args -> args . COMMA arg

    RPAREN          shift and go to state 63
    COMMA           shift and go to state 62


state 55

    (3) import -> IMPORT IDENTIFIER AS . IDENTIFIER

    IDENTIFIER      shift and go to state 64


state 56

    (23) lambda -> LAMBDA LPAREN args . RPAREN expression
    (32) args -> args . COMMA arg

    RPAREN          shift and go to state 65
    COMMA           shift and go to state 62


state 57

    (22) term -> LCBRACE term RCBRACE .

    PLUS            reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    MINUS           reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    TIMES           reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    DIVIDE          reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    PIPE            reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    $end            reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    RPAREN          reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    DO              reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    THEN            reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    COMMA           reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    IN              reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    ELSE            reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    LPAREN          reduce using rule 22 (term -> LCBRACE term RCBRACE .)
    RCBRACE         reduce using rule 22 (term -> LCBRACE term RCBRACE .)


state 58

    (6) expression -> LET IDENTIFIER EQUALS expression . IN expression
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    IN              shift and go to state 66
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29


state 59

    (18) expression -> WHILE expression DO expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 18 (expression -> WHILE expression DO expression .)
    RPAREN          reduce using rule 18 (expression -> WHILE expression DO expression .)
    DO              reduce using rule 18 (expression -> WHILE expression DO expression .)
    THEN            reduce using rule 18 (expression -> WHILE expression DO expression .)
    COMMA           reduce using rule 18 (expression -> WHILE expression DO expression .)
    IN              reduce using rule 18 (expression -> WHILE expression DO expression .)
    ELSE            reduce using rule 18 (expression -> WHILE expression DO expression .)
    LPAREN          reduce using rule 18 (expression -> WHILE expression DO expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29

  ! PLUS            [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! MINUS           [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! TIMES           [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! DIVIDE          [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! PIPE            [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]


state 60

    (19) expression -> IF expression THEN expression . ELSE expression
    (20) expression -> IF expression THEN expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    ELSE            shift and go to state 67
    $end            reduce using rule 20 (expression -> IF expression THEN expression .)
    RPAREN          reduce using rule 20 (expression -> IF expression THEN expression .)
    DO              reduce using rule 20 (expression -> IF expression THEN expression .)
    THEN            reduce using rule 20 (expression -> IF expression THEN expression .)
    COMMA           reduce using rule 20 (expression -> IF expression THEN expression .)
    IN              reduce using rule 20 (expression -> IF expression THEN expression .)
    LPAREN          reduce using rule 20 (expression -> IF expression THEN expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29

  ! PLUS            [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! MINUS           [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! TIMES           [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! DIVIDE          [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! PIPE            [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! ELSE            [ reduce using rule 20 (expression -> IF expression THEN expression .) ]


state 61

    (28) function_call -> function_call LPAREN args RPAREN .

    LPAREN          reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    PLUS            reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    MINUS           reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    TIMES           reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    DIVIDE          reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    PIPE            reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    $end            reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    RPAREN          reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    DO              reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    THEN            reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    COMMA           reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    IN              reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)
    ELSE            reduce using rule 28 (function_call -> function_call LPAREN args RPAREN .)


state 62

    (32) args -> args COMMA . arg
    (35) arg -> . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    arg                            shift and go to state 68
    expression                     shift and go to state 53
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 63

    (30) function_call -> lambda LPAREN args RPAREN .

    LPAREN          reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    PLUS            reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    MINUS           reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    TIMES           reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    DIVIDE          reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    PIPE            reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    $end            reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    RPAREN          reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    DO              reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    THEN            reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    COMMA           reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    IN              reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)
    ELSE            reduce using rule 30 (function_call -> lambda LPAREN args RPAREN .)


state 64

    (3) import -> IMPORT IDENTIFIER AS IDENTIFIER .

    LET             reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    MINUS           reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LPAREN          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    WHILE           reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IF              reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LAZY            reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IMPORT          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IDENTIFIER      reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LAMBDA          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LCBRACE         reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    STRING          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    NUMBER          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    TRUE            reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    FALSE           reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)


state 65

    (23) lambda -> LAMBDA LPAREN args RPAREN . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 69
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 66

    (6) expression -> LET IDENTIFIER EQUALS expression IN . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 70
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 67

    (19) expression -> IF expression THEN expression ELSE . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . lambda
    (27) expression -> . term
    (28) function_call -> . function_call LPAREN args RPAREN
    (29) function_call -> . function_call LPAREN RPAREN
    (30) function_call -> . lambda LPAREN args RPAREN
    (31) function_call -> . IDENTIFIER
    (23) lambda -> . LAMBDA LPAREN args RPAREN expression
    (13) term -> . factor
    (22) term -> . LCBRACE term RCBRACE
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    IDENTIFIER      shift and go to state 6
    LAMBDA          shift and go to state 16
    LCBRACE         shift and go to state 18
    STRING          shift and go to state 19
    NUMBER          shift and go to state 20
    TRUE            shift and go to state 21
    FALSE           shift and go to state 22

    expression                     shift and go to state 71
    function_call                  shift and go to state 12
    lambda                         shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 68

    (32) args -> args COMMA arg .

    RPAREN          reduce using rule 32 (args -> args COMMA arg .)
    COMMA           reduce using rule 32 (args -> args COMMA arg .)


state 69

    (23) lambda -> LAMBDA LPAREN args RPAREN expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    LPAREN          reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    $end            reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    RPAREN          reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    DO              reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    THEN            reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    COMMA           reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    IN              reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    ELSE            reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29

  ! PLUS            [ reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .) ]
  ! MINUS           [ reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .) ]
  ! TIMES           [ reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .) ]
  ! DIVIDE          [ reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .) ]
  ! PIPE            [ reduce using rule 23 (lambda -> LAMBDA LPAREN args RPAREN expression .) ]


state 70

    (6) expression -> LET IDENTIFIER EQUALS expression IN expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    RPAREN          reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    DO              reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    THEN            reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    COMMA           reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    IN              reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    ELSE            reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    LPAREN          reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29

  ! PLUS            [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! MINUS           [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! TIMES           [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! DIVIDE          [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! PIPE            [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]


state 71

    (19) expression -> IF expression THEN expression ELSE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    RPAREN          reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    DO              reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    THEN            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    COMMA           reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    IN              reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    ELSE            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    LPAREN          reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    PIPE            shift and go to state 29

  ! PLUS            [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! MINUS           [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! TIMES           [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! DIVIDE          [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! PIPE            [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 12 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 13 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 35 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 35 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 35 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 36 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 59 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 59 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 59 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 60 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 60 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 60 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 69 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 70 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 70 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 71 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 71 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 71 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 71 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 71 resolved as shift
