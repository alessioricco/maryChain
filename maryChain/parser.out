Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BOOLEAN
    BOOLEANCAST
    CATCH
    DEF
    DOT
    DOUBLECAST
    EMPTY
    EQUALITY
    FINALLY
    FOREACH
    FUNC
    GREATER
    GREATEREQUAL
    HEAD
    IMPLIES
    INTEGERCAST
    LBRACK
    LEN
    LESS
    LESSEQUAL
    NAMESPACE_OP
    NOT
    NULL
    OR
    RBRACK
    STRINGCAST
    TAIL
    TRY

Grammar

Rule 0     S' -> program
Rule 1     program -> imports expression
Rule 2     program -> expression
Rule 3     import -> IMPORT IDENTIFIER AS IDENTIFIER
Rule 4     imports -> import
Rule 5     imports -> imports import
Rule 6     expression -> LET IDENTIFIER EQUALS expression IN expression
Rule 7     expression -> expression PLUS expression
Rule 8     expression -> expression MINUS expression
Rule 9     expression -> expression TIMES expression
Rule 10    expression -> expression DIVIDE expression
Rule 11    expression -> MINUS expression
Rule 12    expression -> LPAREN expression RPAREN
Rule 13    term -> factor
Rule 14    factor -> STRING
Rule 15    factor -> NUMBER
Rule 16    factor -> TRUE
Rule 17    factor -> FALSE
Rule 18    expression -> WHILE expression DO expression
Rule 19    expression -> IF expression THEN expression ELSE expression
Rule 20    expression -> IF expression THEN expression
Rule 21    expression -> LAZY expression
Rule 22    expression -> LCBRACE expression RCBRACE
Rule 23    function_call -> LAMBDA LPAREN args RPAREN expression
Rule 24    expression -> expression PIPE expression
Rule 25    expression -> function_call
Rule 26    expression -> term
Rule 27    function_call -> function_call LPAREN args RPAREN
Rule 28    function_call -> function_call LPAREN RPAREN
Rule 29    function_call -> IDENTIFIER
Rule 30    args -> args COMMA arg
Rule 31    args -> arg
Rule 32    args -> <empty>
Rule 33    arg -> expression

Terminals, with rules where they appear

AND                  : 
AS                   : 3
BOOLEAN              : 
BOOLEANCAST          : 
CATCH                : 
COMMA                : 30
DEF                  : 
DIVIDE               : 10
DO                   : 18
DOT                  : 
DOUBLECAST           : 
ELSE                 : 19
EMPTY                : 
EQUALITY             : 
EQUALS               : 6
FALSE                : 17
FINALLY              : 
FOREACH              : 
FUNC                 : 
GREATER              : 
GREATEREQUAL         : 
HEAD                 : 
IDENTIFIER           : 3 3 6 29
IF                   : 19 20
IMPLIES              : 
IMPORT               : 3
IN                   : 6
INTEGERCAST          : 
LAMBDA               : 23
LAZY                 : 21
LBRACK               : 
LCBRACE              : 22
LEN                  : 
LESS                 : 
LESSEQUAL            : 
LET                  : 6
LPAREN               : 12 23 27 28
MINUS                : 8 11
NAMESPACE_OP         : 
NOT                  : 
NULL                 : 
NUMBER               : 15
OR                   : 
PIPE                 : 24
PLUS                 : 7
RBRACK               : 
RCBRACE              : 22
RPAREN               : 12 23 27 28
STRING               : 14
STRINGCAST           : 
TAIL                 : 
THEN                 : 19 20
TIMES                : 9
TRUE                 : 16
TRY                  : 
WHILE                : 18
error                : 

Nonterminals, with rules where they appear

arg                  : 30 31
args                 : 23 27 30
expression           : 1 2 6 6 7 7 8 8 9 9 10 10 11 12 18 18 19 19 19 20 20 21 22 23 24 24 33
factor               : 13
function_call        : 25 27 28
import               : 4 5
imports              : 1 5
program              : 0
term                 : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . imports expression
    (2) program -> . expression
    (4) imports -> . import
    (5) imports -> . imports import
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (3) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    IMPORT          shift and go to state 15
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    program                        shift and go to state 1
    imports                        shift and go to state 2
    expression                     shift and go to state 3
    import                         shift and go to state 4
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 1

    (0) S' -> program .



state 2

    (1) program -> imports . expression
    (5) imports -> imports . import
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (3) import -> . IMPORT IDENTIFIER AS IDENTIFIER
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    IMPORT          shift and go to state 15
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 22
    import                         shift and go to state 23
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 3

    (2) program -> expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    $end            reduce using rule 2 (program -> expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 4

    (4) imports -> import .

    LET             reduce using rule 4 (imports -> import .)
    MINUS           reduce using rule 4 (imports -> import .)
    LPAREN          reduce using rule 4 (imports -> import .)
    WHILE           reduce using rule 4 (imports -> import .)
    IF              reduce using rule 4 (imports -> import .)
    LAZY            reduce using rule 4 (imports -> import .)
    LCBRACE         reduce using rule 4 (imports -> import .)
    IMPORT          reduce using rule 4 (imports -> import .)
    LAMBDA          reduce using rule 4 (imports -> import .)
    IDENTIFIER      reduce using rule 4 (imports -> import .)
    STRING          reduce using rule 4 (imports -> import .)
    NUMBER          reduce using rule 4 (imports -> import .)
    TRUE            reduce using rule 4 (imports -> import .)
    FALSE           reduce using rule 4 (imports -> import .)


state 5

    (6) expression -> LET . IDENTIFIER EQUALS expression IN expression

    IDENTIFIER      shift and go to state 29


state 6

    (29) function_call -> IDENTIFIER .

    LPAREN          reduce using rule 29 (function_call -> IDENTIFIER .)
    PLUS            reduce using rule 29 (function_call -> IDENTIFIER .)
    MINUS           reduce using rule 29 (function_call -> IDENTIFIER .)
    TIMES           reduce using rule 29 (function_call -> IDENTIFIER .)
    DIVIDE          reduce using rule 29 (function_call -> IDENTIFIER .)
    PIPE            reduce using rule 29 (function_call -> IDENTIFIER .)
    $end            reduce using rule 29 (function_call -> IDENTIFIER .)
    RPAREN          reduce using rule 29 (function_call -> IDENTIFIER .)
    DO              reduce using rule 29 (function_call -> IDENTIFIER .)
    THEN            reduce using rule 29 (function_call -> IDENTIFIER .)
    RCBRACE         reduce using rule 29 (function_call -> IDENTIFIER .)
    COMMA           reduce using rule 29 (function_call -> IDENTIFIER .)
    IN              reduce using rule 29 (function_call -> IDENTIFIER .)
    ELSE            reduce using rule 29 (function_call -> IDENTIFIER .)


state 7

    (11) expression -> MINUS . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 30
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 8

    (12) expression -> LPAREN . expression RPAREN
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 31
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 9

    (18) expression -> WHILE . expression DO expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 32
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 10

    (19) expression -> IF . expression THEN expression ELSE expression
    (20) expression -> IF . expression THEN expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 33
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 11

    (21) expression -> LAZY . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 34
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 12

    (22) expression -> LCBRACE . expression RCBRACE
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 35
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 13

    (25) expression -> function_call .
    (27) function_call -> function_call . LPAREN args RPAREN
    (28) function_call -> function_call . LPAREN RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    PLUS            reduce using rule 25 (expression -> function_call .)
    MINUS           reduce using rule 25 (expression -> function_call .)
    TIMES           reduce using rule 25 (expression -> function_call .)
    DIVIDE          reduce using rule 25 (expression -> function_call .)
    PIPE            reduce using rule 25 (expression -> function_call .)
    $end            reduce using rule 25 (expression -> function_call .)
    RPAREN          reduce using rule 25 (expression -> function_call .)
    DO              reduce using rule 25 (expression -> function_call .)
    THEN            reduce using rule 25 (expression -> function_call .)
    RCBRACE         reduce using rule 25 (expression -> function_call .)
    COMMA           reduce using rule 25 (expression -> function_call .)
    IN              reduce using rule 25 (expression -> function_call .)
    ELSE            reduce using rule 25 (expression -> function_call .)
    LPAREN          shift and go to state 36

  ! LPAREN          [ reduce using rule 25 (expression -> function_call .) ]


state 14

    (26) expression -> term .

    PLUS            reduce using rule 26 (expression -> term .)
    MINUS           reduce using rule 26 (expression -> term .)
    TIMES           reduce using rule 26 (expression -> term .)
    DIVIDE          reduce using rule 26 (expression -> term .)
    PIPE            reduce using rule 26 (expression -> term .)
    $end            reduce using rule 26 (expression -> term .)
    RPAREN          reduce using rule 26 (expression -> term .)
    DO              reduce using rule 26 (expression -> term .)
    THEN            reduce using rule 26 (expression -> term .)
    RCBRACE         reduce using rule 26 (expression -> term .)
    COMMA           reduce using rule 26 (expression -> term .)
    IN              reduce using rule 26 (expression -> term .)
    ELSE            reduce using rule 26 (expression -> term .)
    LPAREN          reduce using rule 26 (expression -> term .)


state 15

    (3) import -> IMPORT . IDENTIFIER AS IDENTIFIER

    IDENTIFIER      shift and go to state 37


state 16

    (23) function_call -> LAMBDA . LPAREN args RPAREN expression

    LPAREN          shift and go to state 38


state 17

    (13) term -> factor .

    PLUS            reduce using rule 13 (term -> factor .)
    MINUS           reduce using rule 13 (term -> factor .)
    TIMES           reduce using rule 13 (term -> factor .)
    DIVIDE          reduce using rule 13 (term -> factor .)
    PIPE            reduce using rule 13 (term -> factor .)
    $end            reduce using rule 13 (term -> factor .)
    RPAREN          reduce using rule 13 (term -> factor .)
    DO              reduce using rule 13 (term -> factor .)
    THEN            reduce using rule 13 (term -> factor .)
    RCBRACE         reduce using rule 13 (term -> factor .)
    COMMA           reduce using rule 13 (term -> factor .)
    IN              reduce using rule 13 (term -> factor .)
    ELSE            reduce using rule 13 (term -> factor .)
    LPAREN          reduce using rule 13 (term -> factor .)


state 18

    (14) factor -> STRING .

    PLUS            reduce using rule 14 (factor -> STRING .)
    MINUS           reduce using rule 14 (factor -> STRING .)
    TIMES           reduce using rule 14 (factor -> STRING .)
    DIVIDE          reduce using rule 14 (factor -> STRING .)
    PIPE            reduce using rule 14 (factor -> STRING .)
    $end            reduce using rule 14 (factor -> STRING .)
    RPAREN          reduce using rule 14 (factor -> STRING .)
    DO              reduce using rule 14 (factor -> STRING .)
    THEN            reduce using rule 14 (factor -> STRING .)
    RCBRACE         reduce using rule 14 (factor -> STRING .)
    COMMA           reduce using rule 14 (factor -> STRING .)
    IN              reduce using rule 14 (factor -> STRING .)
    ELSE            reduce using rule 14 (factor -> STRING .)
    LPAREN          reduce using rule 14 (factor -> STRING .)


state 19

    (15) factor -> NUMBER .

    PLUS            reduce using rule 15 (factor -> NUMBER .)
    MINUS           reduce using rule 15 (factor -> NUMBER .)
    TIMES           reduce using rule 15 (factor -> NUMBER .)
    DIVIDE          reduce using rule 15 (factor -> NUMBER .)
    PIPE            reduce using rule 15 (factor -> NUMBER .)
    $end            reduce using rule 15 (factor -> NUMBER .)
    RPAREN          reduce using rule 15 (factor -> NUMBER .)
    DO              reduce using rule 15 (factor -> NUMBER .)
    THEN            reduce using rule 15 (factor -> NUMBER .)
    RCBRACE         reduce using rule 15 (factor -> NUMBER .)
    COMMA           reduce using rule 15 (factor -> NUMBER .)
    IN              reduce using rule 15 (factor -> NUMBER .)
    ELSE            reduce using rule 15 (factor -> NUMBER .)
    LPAREN          reduce using rule 15 (factor -> NUMBER .)


state 20

    (16) factor -> TRUE .

    PLUS            reduce using rule 16 (factor -> TRUE .)
    MINUS           reduce using rule 16 (factor -> TRUE .)
    TIMES           reduce using rule 16 (factor -> TRUE .)
    DIVIDE          reduce using rule 16 (factor -> TRUE .)
    PIPE            reduce using rule 16 (factor -> TRUE .)
    $end            reduce using rule 16 (factor -> TRUE .)
    RPAREN          reduce using rule 16 (factor -> TRUE .)
    DO              reduce using rule 16 (factor -> TRUE .)
    THEN            reduce using rule 16 (factor -> TRUE .)
    RCBRACE         reduce using rule 16 (factor -> TRUE .)
    COMMA           reduce using rule 16 (factor -> TRUE .)
    IN              reduce using rule 16 (factor -> TRUE .)
    ELSE            reduce using rule 16 (factor -> TRUE .)
    LPAREN          reduce using rule 16 (factor -> TRUE .)


state 21

    (17) factor -> FALSE .

    PLUS            reduce using rule 17 (factor -> FALSE .)
    MINUS           reduce using rule 17 (factor -> FALSE .)
    TIMES           reduce using rule 17 (factor -> FALSE .)
    DIVIDE          reduce using rule 17 (factor -> FALSE .)
    PIPE            reduce using rule 17 (factor -> FALSE .)
    $end            reduce using rule 17 (factor -> FALSE .)
    RPAREN          reduce using rule 17 (factor -> FALSE .)
    DO              reduce using rule 17 (factor -> FALSE .)
    THEN            reduce using rule 17 (factor -> FALSE .)
    RCBRACE         reduce using rule 17 (factor -> FALSE .)
    COMMA           reduce using rule 17 (factor -> FALSE .)
    IN              reduce using rule 17 (factor -> FALSE .)
    ELSE            reduce using rule 17 (factor -> FALSE .)
    LPAREN          reduce using rule 17 (factor -> FALSE .)


state 22

    (1) program -> imports expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    $end            reduce using rule 1 (program -> imports expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 23

    (5) imports -> imports import .

    LET             reduce using rule 5 (imports -> imports import .)
    MINUS           reduce using rule 5 (imports -> imports import .)
    LPAREN          reduce using rule 5 (imports -> imports import .)
    WHILE           reduce using rule 5 (imports -> imports import .)
    IF              reduce using rule 5 (imports -> imports import .)
    LAZY            reduce using rule 5 (imports -> imports import .)
    LCBRACE         reduce using rule 5 (imports -> imports import .)
    IMPORT          reduce using rule 5 (imports -> imports import .)
    LAMBDA          reduce using rule 5 (imports -> imports import .)
    IDENTIFIER      reduce using rule 5 (imports -> imports import .)
    STRING          reduce using rule 5 (imports -> imports import .)
    NUMBER          reduce using rule 5 (imports -> imports import .)
    TRUE            reduce using rule 5 (imports -> imports import .)
    FALSE           reduce using rule 5 (imports -> imports import .)


state 24

    (7) expression -> expression PLUS . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 39
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 25

    (8) expression -> expression MINUS . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 40
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 26

    (9) expression -> expression TIMES . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 41
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 27

    (10) expression -> expression DIVIDE . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 42
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 28

    (24) expression -> expression PIPE . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 43
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 29

    (6) expression -> LET IDENTIFIER . EQUALS expression IN expression

    EQUALS          shift and go to state 44


state 30

    (11) expression -> MINUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PIPE            reduce using rule 11 (expression -> MINUS expression .)
    $end            reduce using rule 11 (expression -> MINUS expression .)
    RPAREN          reduce using rule 11 (expression -> MINUS expression .)
    DO              reduce using rule 11 (expression -> MINUS expression .)
    THEN            reduce using rule 11 (expression -> MINUS expression .)
    RCBRACE         reduce using rule 11 (expression -> MINUS expression .)
    COMMA           reduce using rule 11 (expression -> MINUS expression .)
    IN              reduce using rule 11 (expression -> MINUS expression .)
    ELSE            reduce using rule 11 (expression -> MINUS expression .)
    LPAREN          reduce using rule 11 (expression -> MINUS expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27

  ! PLUS            [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! TIMES           [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 11 (expression -> MINUS expression .) ]
  ! PIPE            [ shift and go to state 28 ]


state 31

    (12) expression -> LPAREN expression . RPAREN
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    RPAREN          shift and go to state 45
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 32

    (18) expression -> WHILE expression . DO expression
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    DO              shift and go to state 46
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 33

    (19) expression -> IF expression . THEN expression ELSE expression
    (20) expression -> IF expression . THEN expression
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    THEN            shift and go to state 47
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 34

    (21) expression -> LAZY expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 21 (expression -> LAZY expression .)
    RPAREN          reduce using rule 21 (expression -> LAZY expression .)
    DO              reduce using rule 21 (expression -> LAZY expression .)
    THEN            reduce using rule 21 (expression -> LAZY expression .)
    RCBRACE         reduce using rule 21 (expression -> LAZY expression .)
    COMMA           reduce using rule 21 (expression -> LAZY expression .)
    IN              reduce using rule 21 (expression -> LAZY expression .)
    ELSE            reduce using rule 21 (expression -> LAZY expression .)
    LPAREN          reduce using rule 21 (expression -> LAZY expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28

  ! PLUS            [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! MINUS           [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! TIMES           [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! DIVIDE          [ reduce using rule 21 (expression -> LAZY expression .) ]
  ! PIPE            [ reduce using rule 21 (expression -> LAZY expression .) ]


state 35

    (22) expression -> LCBRACE expression . RCBRACE
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    RCBRACE         shift and go to state 48
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 36

    (27) function_call -> function_call LPAREN . args RPAREN
    (28) function_call -> function_call LPAREN . RPAREN
    (30) args -> . args COMMA arg
    (31) args -> . arg
    (32) args -> .
    (33) arg -> . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 50
    COMMA           reduce using rule 32 (args -> .)
    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

  ! RPAREN          [ reduce using rule 32 (args -> .) ]

    function_call                  shift and go to state 13
    args                           shift and go to state 49
    arg                            shift and go to state 51
    expression                     shift and go to state 52
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 37

    (3) import -> IMPORT IDENTIFIER . AS IDENTIFIER

    AS              shift and go to state 53


state 38

    (23) function_call -> LAMBDA LPAREN . args RPAREN expression
    (30) args -> . args COMMA arg
    (31) args -> . arg
    (32) args -> .
    (33) arg -> . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    RPAREN          reduce using rule 32 (args -> .)
    COMMA           reduce using rule 32 (args -> .)
    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    args                           shift and go to state 54
    expression                     shift and go to state 52
    arg                            shift and go to state 51
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 39

    (7) expression -> expression PLUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 7 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 7 (expression -> expression PLUS expression .)
    PIPE            reduce using rule 7 (expression -> expression PLUS expression .)
    $end            reduce using rule 7 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 7 (expression -> expression PLUS expression .)
    DO              reduce using rule 7 (expression -> expression PLUS expression .)
    THEN            reduce using rule 7 (expression -> expression PLUS expression .)
    RCBRACE         reduce using rule 7 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 7 (expression -> expression PLUS expression .)
    IN              reduce using rule 7 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 7 (expression -> expression PLUS expression .)
    LPAREN          reduce using rule 7 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27

  ! TIMES           [ reduce using rule 7 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 7 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 24 ]
  ! MINUS           [ shift and go to state 25 ]
  ! PIPE            [ shift and go to state 28 ]


state 40

    (8) expression -> expression MINUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 8 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 8 (expression -> expression MINUS expression .)
    PIPE            reduce using rule 8 (expression -> expression MINUS expression .)
    $end            reduce using rule 8 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 8 (expression -> expression MINUS expression .)
    DO              reduce using rule 8 (expression -> expression MINUS expression .)
    THEN            reduce using rule 8 (expression -> expression MINUS expression .)
    RCBRACE         reduce using rule 8 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 8 (expression -> expression MINUS expression .)
    IN              reduce using rule 8 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 8 (expression -> expression MINUS expression .)
    LPAREN          reduce using rule 8 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27

  ! TIMES           [ reduce using rule 8 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 8 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 24 ]
  ! MINUS           [ shift and go to state 25 ]
  ! PIPE            [ shift and go to state 28 ]


state 41

    (9) expression -> expression TIMES expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 9 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 9 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 9 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 9 (expression -> expression TIMES expression .)
    PIPE            reduce using rule 9 (expression -> expression TIMES expression .)
    $end            reduce using rule 9 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 9 (expression -> expression TIMES expression .)
    DO              reduce using rule 9 (expression -> expression TIMES expression .)
    THEN            reduce using rule 9 (expression -> expression TIMES expression .)
    RCBRACE         reduce using rule 9 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 9 (expression -> expression TIMES expression .)
    IN              reduce using rule 9 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 9 (expression -> expression TIMES expression .)
    LPAREN          reduce using rule 9 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 24 ]
  ! MINUS           [ shift and go to state 25 ]
  ! TIMES           [ shift and go to state 26 ]
  ! DIVIDE          [ shift and go to state 27 ]
  ! PIPE            [ shift and go to state 28 ]


state 42

    (10) expression -> expression DIVIDE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PLUS            reduce using rule 10 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 10 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 10 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 10 (expression -> expression DIVIDE expression .)
    PIPE            reduce using rule 10 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 10 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 10 (expression -> expression DIVIDE expression .)
    DO              reduce using rule 10 (expression -> expression DIVIDE expression .)
    THEN            reduce using rule 10 (expression -> expression DIVIDE expression .)
    RCBRACE         reduce using rule 10 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 10 (expression -> expression DIVIDE expression .)
    IN              reduce using rule 10 (expression -> expression DIVIDE expression .)
    ELSE            reduce using rule 10 (expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 10 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 24 ]
  ! MINUS           [ shift and go to state 25 ]
  ! TIMES           [ shift and go to state 26 ]
  ! DIVIDE          [ shift and go to state 27 ]
  ! PIPE            [ shift and go to state 28 ]


state 43

    (24) expression -> expression PIPE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    PIPE            reduce using rule 24 (expression -> expression PIPE expression .)
    $end            reduce using rule 24 (expression -> expression PIPE expression .)
    RPAREN          reduce using rule 24 (expression -> expression PIPE expression .)
    DO              reduce using rule 24 (expression -> expression PIPE expression .)
    THEN            reduce using rule 24 (expression -> expression PIPE expression .)
    RCBRACE         reduce using rule 24 (expression -> expression PIPE expression .)
    COMMA           reduce using rule 24 (expression -> expression PIPE expression .)
    IN              reduce using rule 24 (expression -> expression PIPE expression .)
    ELSE            reduce using rule 24 (expression -> expression PIPE expression .)
    LPAREN          reduce using rule 24 (expression -> expression PIPE expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27

  ! PLUS            [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! MINUS           [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! TIMES           [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! DIVIDE          [ reduce using rule 24 (expression -> expression PIPE expression .) ]
  ! PIPE            [ shift and go to state 28 ]


state 44

    (6) expression -> LET IDENTIFIER EQUALS . expression IN expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 55
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 45

    (12) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    PIPE            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    DO              reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    THEN            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    RCBRACE         reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    IN              reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 12 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 12 (expression -> LPAREN expression RPAREN .)


state 46

    (18) expression -> WHILE expression DO . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 56
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 47

    (19) expression -> IF expression THEN . expression ELSE expression
    (20) expression -> IF expression THEN . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 57
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 48

    (22) expression -> LCBRACE expression RCBRACE .

    PLUS            reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    MINUS           reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    TIMES           reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    DIVIDE          reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    PIPE            reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    $end            reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    RPAREN          reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    DO              reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    THEN            reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    RCBRACE         reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    COMMA           reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    IN              reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    ELSE            reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)
    LPAREN          reduce using rule 22 (expression -> LCBRACE expression RCBRACE .)


state 49

    (27) function_call -> function_call LPAREN args . RPAREN
    (30) args -> args . COMMA arg

    RPAREN          shift and go to state 58
    COMMA           shift and go to state 59


state 50

    (28) function_call -> function_call LPAREN RPAREN .

    LPAREN          reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    PLUS            reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    MINUS           reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    TIMES           reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    DIVIDE          reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    PIPE            reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    $end            reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    RPAREN          reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    DO              reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    THEN            reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    RCBRACE         reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    COMMA           reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    IN              reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)
    ELSE            reduce using rule 28 (function_call -> function_call LPAREN RPAREN .)


state 51

    (31) args -> arg .

    RPAREN          reduce using rule 31 (args -> arg .)
    COMMA           reduce using rule 31 (args -> arg .)


state 52

    (33) arg -> expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    RPAREN          reduce using rule 33 (arg -> expression .)
    COMMA           reduce using rule 33 (arg -> expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 53

    (3) import -> IMPORT IDENTIFIER AS . IDENTIFIER

    IDENTIFIER      shift and go to state 60


state 54

    (23) function_call -> LAMBDA LPAREN args . RPAREN expression
    (30) args -> args . COMMA arg

    RPAREN          shift and go to state 61
    COMMA           shift and go to state 59


state 55

    (6) expression -> LET IDENTIFIER EQUALS expression . IN expression
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

    IN              shift and go to state 62
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28


state 56

    (18) expression -> WHILE expression DO expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 18 (expression -> WHILE expression DO expression .)
    RPAREN          reduce using rule 18 (expression -> WHILE expression DO expression .)
    DO              reduce using rule 18 (expression -> WHILE expression DO expression .)
    THEN            reduce using rule 18 (expression -> WHILE expression DO expression .)
    RCBRACE         reduce using rule 18 (expression -> WHILE expression DO expression .)
    COMMA           reduce using rule 18 (expression -> WHILE expression DO expression .)
    IN              reduce using rule 18 (expression -> WHILE expression DO expression .)
    ELSE            reduce using rule 18 (expression -> WHILE expression DO expression .)
    LPAREN          reduce using rule 18 (expression -> WHILE expression DO expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28

  ! PLUS            [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! MINUS           [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! TIMES           [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! DIVIDE          [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]
  ! PIPE            [ reduce using rule 18 (expression -> WHILE expression DO expression .) ]


state 57

    (19) expression -> IF expression THEN expression . ELSE expression
    (20) expression -> IF expression THEN expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    ELSE            shift and go to state 63
    $end            reduce using rule 20 (expression -> IF expression THEN expression .)
    RPAREN          reduce using rule 20 (expression -> IF expression THEN expression .)
    DO              reduce using rule 20 (expression -> IF expression THEN expression .)
    THEN            reduce using rule 20 (expression -> IF expression THEN expression .)
    RCBRACE         reduce using rule 20 (expression -> IF expression THEN expression .)
    COMMA           reduce using rule 20 (expression -> IF expression THEN expression .)
    IN              reduce using rule 20 (expression -> IF expression THEN expression .)
    LPAREN          reduce using rule 20 (expression -> IF expression THEN expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28

  ! PLUS            [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! MINUS           [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! TIMES           [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! DIVIDE          [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! PIPE            [ reduce using rule 20 (expression -> IF expression THEN expression .) ]
  ! ELSE            [ reduce using rule 20 (expression -> IF expression THEN expression .) ]


state 58

    (27) function_call -> function_call LPAREN args RPAREN .

    LPAREN          reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    PLUS            reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    MINUS           reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    TIMES           reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    DIVIDE          reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    PIPE            reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    $end            reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    RPAREN          reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    DO              reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    THEN            reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    RCBRACE         reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    COMMA           reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    IN              reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)
    ELSE            reduce using rule 27 (function_call -> function_call LPAREN args RPAREN .)


state 59

    (30) args -> args COMMA . arg
    (33) arg -> . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    arg                            shift and go to state 64
    expression                     shift and go to state 52
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 60

    (3) import -> IMPORT IDENTIFIER AS IDENTIFIER .

    LET             reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    MINUS           reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LPAREN          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    WHILE           reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IF              reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LAZY            reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LCBRACE         reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IMPORT          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    LAMBDA          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    IDENTIFIER      reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    STRING          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    NUMBER          reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    TRUE            reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)
    FALSE           reduce using rule 3 (import -> IMPORT IDENTIFIER AS IDENTIFIER .)


state 61

    (23) function_call -> LAMBDA LPAREN args RPAREN . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 65
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 62

    (6) expression -> LET IDENTIFIER EQUALS expression IN . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 66
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 63

    (19) expression -> IF expression THEN expression ELSE . expression
    (6) expression -> . LET IDENTIFIER EQUALS expression IN expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . MINUS expression
    (12) expression -> . LPAREN expression RPAREN
    (18) expression -> . WHILE expression DO expression
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IF expression THEN expression
    (21) expression -> . LAZY expression
    (22) expression -> . LCBRACE expression RCBRACE
    (24) expression -> . expression PIPE expression
    (25) expression -> . function_call
    (26) expression -> . term
    (23) function_call -> . LAMBDA LPAREN args RPAREN expression
    (27) function_call -> . function_call LPAREN args RPAREN
    (28) function_call -> . function_call LPAREN RPAREN
    (29) function_call -> . IDENTIFIER
    (13) term -> . factor
    (14) factor -> . STRING
    (15) factor -> . NUMBER
    (16) factor -> . TRUE
    (17) factor -> . FALSE

    LET             shift and go to state 5
    MINUS           shift and go to state 7
    LPAREN          shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    LAZY            shift and go to state 11
    LCBRACE         shift and go to state 12
    LAMBDA          shift and go to state 16
    IDENTIFIER      shift and go to state 6
    STRING          shift and go to state 18
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21

    expression                     shift and go to state 67
    function_call                  shift and go to state 13
    term                           shift and go to state 14
    factor                         shift and go to state 17

state 64

    (30) args -> args COMMA arg .

    RPAREN          reduce using rule 30 (args -> args COMMA arg .)
    COMMA           reduce using rule 30 (args -> args COMMA arg .)


state 65

    (23) function_call -> LAMBDA LPAREN args RPAREN expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    LPAREN          reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    $end            reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    RPAREN          reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    DO              reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    THEN            reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    RCBRACE         reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    COMMA           reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    IN              reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    ELSE            reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28

  ! PLUS            [ reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .) ]
  ! MINUS           [ reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .) ]
  ! TIMES           [ reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .) ]
  ! DIVIDE          [ reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .) ]
  ! PIPE            [ reduce using rule 23 (function_call -> LAMBDA LPAREN args RPAREN expression .) ]


state 66

    (6) expression -> LET IDENTIFIER EQUALS expression IN expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    RPAREN          reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    DO              reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    THEN            reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    RCBRACE         reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    COMMA           reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    IN              reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    ELSE            reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    LPAREN          reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28

  ! PLUS            [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! MINUS           [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! TIMES           [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! DIVIDE          [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]
  ! PIPE            [ reduce using rule 6 (expression -> LET IDENTIFIER EQUALS expression IN expression .) ]


state 67

    (19) expression -> IF expression THEN expression ELSE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (24) expression -> expression . PIPE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
    $end            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    RPAREN          reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    DO              reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    THEN            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    RCBRACE         reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    COMMA           reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    IN              reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    ELSE            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    LPAREN          reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27
    PIPE            shift and go to state 28

  ! PLUS            [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! MINUS           [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! TIMES           [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! DIVIDE          [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! PIPE            [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 13 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 34 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 34 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 34 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 34 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 34 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 36 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 56 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 56 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 56 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 57 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 57 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 66 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 66 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 66 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 67 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 67 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 67 resolved as shift
